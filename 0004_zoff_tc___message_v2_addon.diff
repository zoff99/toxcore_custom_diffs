commit 5a4146e600823d49019e3f2213ebf19e8c0057f2
Author: zoff99 <zoff99@users.noreply.github.com>
Date:   Fri Apr 22 19:48:54 2022 +0200

    0004_zoff_tc___message_v2_addon

diff --git a/BUILD.bazel b/BUILD.bazel
index 4d39dab33..af76a9b26 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -11,16 +11,19 @@ genrule(
         "//c-toxcore/toxav:toxav.h",
         "//c-toxcore/toxcore:tox.h",
         "//c-toxcore/toxencryptsave:toxencryptsave.h",
+        "//c-toxcore/toxutil:toxutil.h",
     ],
     outs = [
         "tox/toxav.h",
         "tox/tox.h",
         "tox/toxencryptsave.h",
+        "tox/toxutil.h",
     ],
     cmd = """
         cp $(location //c-toxcore/toxav:toxav.h) $(GENDIR)/c-toxcore/tox/toxav.h
         cp $(location //c-toxcore/toxcore:tox.h) $(GENDIR)/c-toxcore/tox/tox.h
         cp $(location //c-toxcore/toxencryptsave:toxencryptsave.h) $(GENDIR)/c-toxcore/tox/toxencryptsave.h
+        cp $(location //c-toxcore/toxutil:toxutil.h) $(GENDIR)/c-toxcore/toxutil/toxutil.h
     """,
     visibility = ["//visibility:public"],
 )
@@ -34,5 +37,6 @@ cc_library(
         "//c-toxcore/toxav",
         "//c-toxcore/toxcore",
         "//c-toxcore/toxencryptsave",
+        "//c-toxcore/toxutil",
     ],
 )
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7c8b731a3..1d343a997 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -32,6 +32,7 @@ set_source_files_properties(
   toxcore/network.c
   toxcore/tox.c
   toxcore/util.c
+  toxutil/toxutil.c
   PROPERTIES SKIP_UNITY_BUILD_INCLUSION TRUE)
 
 ################################################################################
@@ -308,11 +309,14 @@ set(toxcore_SOURCES
   toxcore/tox_unpack.c
   toxcore/tox_unpack.h
   toxcore/util.c
-  toxcore/util.h)
+  toxcore/util.h
+  toxutil/toxutil.c
+  toxutil/toxutil.h)
 set(toxcore_LINK_MODULES ${toxcore_LINK_MODULES} ${LIBSODIUM_LIBRARIES})
 set(toxcore_PKGCONFIG_REQUIRES ${toxcore_PKGCONFIG_REQUIRES} libsodium)
 set(toxcore_API_HEADERS
   ${toxcore_SOURCE_DIR}/toxcore/tox.h^tox
+  ${toxcore_SOURCE_DIR}/toxutil/toxutil.h^tox
   ${toxcore_SOURCE_DIR}/toxcore/tox_events.h^tox
   ${toxcore_SOURCE_DIR}/toxcore/tox_dispatch.h^tox)
 
diff --git a/other/analysis/gen-file.sh b/other/analysis/gen-file.sh
index 623f8d285..afb594dfa 100644
--- a/other/analysis/gen-file.sh
+++ b/other/analysis/gen-file.sh
@@ -11,6 +11,7 @@ CPPFLAGS+=("-Itesting")
 CPPFLAGS+=("-Itesting/fuzzing")
 CPPFLAGS+=("-Itoxcore")
 CPPFLAGS+=("-Itoxcore/events")
+CPPFLAGS+=("-Itoxutil")
 CPPFLAGS+=("-Itoxav")
 CPPFLAGS+=("-Itoxencryptsave")
 CPPFLAGS+=("-Ithird_party/cmp")
@@ -61,6 +62,7 @@ FIND_QUERY="$FIND_QUERY -and -not -name '*_fuzz_test.cc'"
 FIND_QUERY="$FIND_QUERY -and -not -wholename './testing/fuzzing/*'"
 FIND_QUERY="$FIND_QUERY -and -not -wholename './third_party/cmp/examples/*'"
 FIND_QUERY="$FIND_QUERY -and -not -wholename './third_party/cmp/test/*'"
+FIND_QUERY="$FIND_QUERY -and -not -wholename './toxutil/*'"
 
 if [ "$SKIP_GTEST" == 1 ]; then
   FIND_QUERY="$FIND_QUERY -and -not -name '*_test.cc'"
diff --git a/toxcore/Makefile.inc b/toxcore/Makefile.inc
index c7a01dc30..6904c9ca2 100644
--- a/toxcore/Makefile.inc
+++ b/toxcore/Makefile.inc
@@ -1,7 +1,8 @@
 lib_LTLIBRARIES += libtoxcore.la
 
 libtoxcore_la_include_HEADERS = \
-                        ../toxcore/tox.h
+                        ../toxcore/tox.h \
+                        ../toxutil/toxutil.h
 
 libtoxcore_la_includedir = $(includedir)/tox
 
@@ -113,7 +114,8 @@ libtoxcore_la_SOURCES = ../third_party/cmp/cmp.c \
                         ../toxcore/TCP_connection.h \
                         ../toxcore/TCP_connection.c \
                         ../toxcore/list.c \
-                        ../toxcore/list.h
+                        ../toxcore/list.h \
+                        ../toxutil/toxutil.c
 
 libtoxcore_la_CFLAGS =  -I$(top_srcdir) \
                         -I$(top_srcdir)/toxcore \
diff --git a/toxcore/Messenger.c b/toxcore/Messenger.c
index 35b33c961..098a2e4a8 100644
--- a/toxcore/Messenger.c
+++ b/toxcore/Messenger.c
@@ -24,6 +24,27 @@
 #include "state.h"
 #include "util.h"
 
+
+/**
+ * This is defined in tox.h and "copied" here.
+ * it's wanted not to include tox.h here.
+ * but this solution is BAD, "future me" please fix.
+ */
+#define HACK_TOX_FILE_KIND_MESSAGEV2_SEND 2
+#define HACK_TOX_FILE_KIND_MESSAGEV2_ANSWER 3
+#define HACK_TOX_FILE_KIND_MESSAGEV2_ALTER 4
+#define HACK_TOX_FILE_KIND_MESSAGEV2_SYNC 5
+
+#define HACK_TOX_MESSAGEV2_MAX_NON_SYNC_HEADER_SIZE  (32 + 4 + 2 + 1 + 32)
+#define HACK_TOX_MESSAGEV2_MAX_HEADER_SIZE  (32 + 4 + 2 + 32 + 4)
+#define HACK_TOX_MESSAGEV2_MAX_TEXT_LENGTH  4096
+#define HACK_TOX_MAX_FILETRANSFER_SIZE_MSGV2 (HACK_TOX_MESSAGEV2_MAX_TEXT_LENGTH + HACK_TOX_MESSAGEV2_MAX_HEADER_SIZE + HACK_TOX_MESSAGEV2_MAX_NON_SYNC_HEADER_SIZE)
+/**
+ * This is defined in tox.h and "copied" here.
+ * someone wanted not to include tox.h here
+ */
+
+
 static_assert(MAX_CONCURRENT_FILE_PIPES <= UINT8_MAX + 1,
               "uint8_t cannot represent all file transfer numbers");
 
@@ -1209,6 +1230,19 @@ long int new_filesender(const Messenger *m, int32_t friendnumber, uint32_t file_
         return -2;
     }
 
+    if ((file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SEND)
+            ||
+            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ANSWER)
+            ||
+            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SYNC)
+            ||
+            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ALTER)) {
+        if ((uint64_t)filesize > (uint64_t)HACK_TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
+            // TODO(zoff): define a new error code for this
+            return -2;
+        }
+    }
+
     uint32_t i;
 
     for (i = 0; i < MAX_CONCURRENT_FILE_PIPES; ++i) {
@@ -1227,7 +1261,17 @@ long int new_filesender(const Messenger *m, int32_t friendnumber, uint32_t file_
 
     struct File_Transfers *ft = &m->friendlist[friendnumber].file_sending[i];
 
-    ft->status = FILESTATUS_NOT_ACCEPTED;
+    if ((file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SEND)
+            ||
+            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ANSWER)
+            ||
+            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SYNC)
+            ||
+            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ALTER)) {
+        ft->status = FILESTATUS_TRANSFERRING;
+    } else {
+        ft->status = FILESTATUS_NOT_ACCEPTED;
+    }
 
     ft->size = filesize;
 
@@ -2156,7 +2200,23 @@ static int m_handle_packet(void *object, int i, const uint8_t *temp, uint16_t le
                 break;
             }
 
-            ft->status = FILESTATUS_NOT_ACCEPTED;
+            if ((file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SEND)
+                    ||
+                    (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ANSWER)
+                    ||
+                    (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SYNC)
+                    ||
+                    (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ALTER)) {
+                ft->status = FILESTATUS_TRANSFERRING;
+
+                if ((uint64_t)filesize > (uint64_t)HACK_TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
+                    break;
+                }
+
+            } else {
+                ft->status = FILESTATUS_NOT_ACCEPTED;
+            }
+
             ft->size = filesize;
             ft->transferred = 0;
             ft->paused = FILE_PAUSE_NOT;
diff --git a/toxcore/Messenger.h b/toxcore/Messenger.h
index 04db27c03..4d30f056d 100644
--- a/toxcore/Messenger.h
+++ b/toxcore/Messenger.h
@@ -100,7 +100,7 @@ typedef struct Messenger_Options {
 #define TOX_CAPABILITY_NEXT_IMPLEMENTATION ((uint64_t)1) << 63
 /* hardcoded capabilities of this version/branch of toxcore */
 #ifdef TOX_CAPABILITIES_ACTIVE
-#define TOX_CAPABILITIES_CURRENT (uint64_t)(TOX_CAPABILITY_CAPABILITIES | TOX_CAPABILITY_MSGV3)
+#define TOX_CAPABILITIES_CURRENT (uint64_t)(TOX_CAPABILITY_CAPABILITIES | TOX_CAPABILITY_MSGV2 | TOX_CAPABILITY_MSGV3)
 #else
 #define TOX_CAPABILITIES_CURRENT (uint64_t)(TOX_CAPABILITY_CAPABILITIES)
 #endif
diff --git a/toxcore/tox.c b/toxcore/tox.c
index d8fa28d53..7285b30b4 100644
--- a/toxcore/tox.c
+++ b/toxcore/tox.c
@@ -4575,3 +4575,348 @@ bool tox_group_mod_kick_peer(const Tox *tox, uint32_t group_number, uint32_t pee
 
 #endif /* VANILLA_NACL */
 
+
+/* * * * * * * * * * * * * * *
+ *
+ * MessageV2 functions
+ *
+ * * * * * * * * * * * * * * */
+
+/*
+ * sending
+ */
+uint32_t tox_messagev2_size(uint32_t text_length, uint32_t type, uint32_t alter_type)
+{
+    if (type == TOX_FILE_KIND_MESSAGEV2_SEND) {
+        return (TOX_PUBLIC_KEY_SIZE + 4 + 2 + text_length);
+    } else if (type == TOX_FILE_KIND_MESSAGEV2_SYNC) {
+        return (TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4 + text_length);
+    } else if (type == TOX_FILE_KIND_MESSAGEV2_ANSWER) {
+        return (TOX_PUBLIC_KEY_SIZE + 4 + 2);
+    } else { // TOX_FILE_KIND_MESSAGEV2_ALTER
+        if (alter_type == TOX_MESSAGEV2_ALTER_TYPE_CORRECT) {
+            return (TOX_PUBLIC_KEY_SIZE + 32 + 4 + 2 + 1 + text_length);
+        } else { // TOX_MESSAGEV2_ALTER_TYPE_DELETE
+            return (TOX_PUBLIC_KEY_SIZE + 32 + 4 + 2 + 1);
+        }
+
+    }
+}
+
+
+bool tox_messagev2_sync_wrap(uint32_t data_length, const uint8_t *original_sender_pubkey_bin,
+                             uint32_t data_msg_type,
+                             const uint8_t *raw_data, uint32_t ts_sec,
+                             uint16_t ts_ms, uint8_t *raw_message,
+                             uint8_t *msgid)
+{
+
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    if (msgid == nullptr) {
+        return false;
+    }
+
+    if (original_sender_pubkey_bin == nullptr) {
+        return false;
+    }
+
+    if (raw_data == nullptr) {
+        return false;
+    }
+
+    if (data_length == 0) {
+        return false;
+    }
+
+    // uint8_t nonce[CRYPTO_NONCE_SIZE];
+    // random_nonce(nonce);
+
+    uint8_t *raw_message_cpy = raw_message;
+
+    /* Tox keys are 32 bytes, so we use this directly as new "message id" */
+    new_symmetric_key_implicit_random(msgid);
+
+    memcpy(raw_message_cpy, msgid, TOX_PUBLIC_KEY_SIZE);
+    raw_message_cpy += TOX_PUBLIC_KEY_SIZE;
+
+    memcpy(raw_message_cpy, &ts_sec, 4);
+    raw_message_cpy += 4;
+
+    memcpy(raw_message_cpy, &ts_ms, 2);
+    raw_message_cpy += 2;
+
+    memcpy(raw_message_cpy, original_sender_pubkey_bin, TOX_PUBLIC_KEY_SIZE);
+    raw_message_cpy += TOX_PUBLIC_KEY_SIZE;
+
+    memcpy(raw_message_cpy, &data_msg_type, 4);
+    raw_message_cpy += 4;
+
+    memcpy(raw_message_cpy, raw_data, data_length);
+
+    return true;
+}
+
+bool tox_messagev2_wrap(uint32_t text_length, uint32_t type,
+                        uint32_t alter_type,
+                        const uint8_t *message_text, uint32_t ts_sec,
+                        uint16_t ts_ms, uint8_t *raw_message,
+                        uint8_t *msgid)
+{
+
+    bool result_code = false;
+
+    if (type == TOX_FILE_KIND_MESSAGEV2_SYNC) {
+        return false;
+    }
+
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    if (msgid == nullptr) {
+        return false;
+    }
+
+    if ((message_text == nullptr) && (type == TOX_FILE_KIND_MESSAGEV2_SEND)) {
+        return false;
+    }
+
+    if ((text_length == 0) && (type == TOX_FILE_KIND_MESSAGEV2_SEND)) {
+        return false;
+    }
+
+    if ((message_text == nullptr) && (type == TOX_FILE_KIND_MESSAGEV2_ALTER) &&
+            (alter_type == TOX_MESSAGEV2_ALTER_TYPE_CORRECT)) {
+        return false;
+    }
+
+    if ((text_length == 0) && (type == TOX_FILE_KIND_MESSAGEV2_ALTER) &&
+            (alter_type == TOX_MESSAGEV2_ALTER_TYPE_CORRECT)) {
+        return false;
+    }
+
+    // uint8_t nonce[CRYPTO_NONCE_SIZE];
+    // random_nonce(nonce);
+
+
+    if (type == TOX_FILE_KIND_MESSAGEV2_SEND) {
+
+        uint8_t *raw_message_cpy = raw_message;
+
+        /* Tox keys are 32 bytes, so we use this directly as new "message id" */
+        new_symmetric_key_implicit_random(msgid);
+
+        memcpy(raw_message_cpy, msgid, TOX_PUBLIC_KEY_SIZE);
+        raw_message_cpy += TOX_PUBLIC_KEY_SIZE;
+
+        memcpy(raw_message_cpy, &ts_sec, 4);
+        raw_message_cpy += 4;
+
+        memcpy(raw_message_cpy, &ts_ms, 2);
+        raw_message_cpy += 2;
+
+        memcpy(raw_message_cpy, message_text, text_length);
+
+        result_code = true;
+
+    } else if (type == TOX_FILE_KIND_MESSAGEV2_ANSWER) {
+
+        uint8_t *raw_message_cpy = raw_message;
+
+        memcpy(raw_message_cpy, msgid, TOX_PUBLIC_KEY_SIZE);
+        raw_message_cpy += TOX_PUBLIC_KEY_SIZE;
+
+        memcpy(raw_message_cpy, &ts_sec, 4);
+        raw_message_cpy += 4;
+
+        memcpy(raw_message_cpy, &ts_ms, 2);
+
+        result_code = true;
+
+    } else { // TOX_FILE_KIND_MESSAGEV2_ALTER
+        if (alter_type == TOX_MESSAGEV2_ALTER_TYPE_CORRECT) {
+            // TODO(zoff): * write me *
+            // TODO(zoff): * write me *
+        } else { // TOX_MESSAGEV2_ALTER_TYPE_DELETE
+            // TODO(zoff): * write me *
+            // TODO(zoff): * write me *
+        }
+    }
+
+    return result_code;
+}
+
+/*
+ * receiving
+ */
+bool tox_messagev2_get_message_id(const uint8_t *raw_message, uint8_t *msg_id)
+{
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    if (msg_id == nullptr) {
+        return false;
+    }
+
+    memcpy(msg_id, raw_message, TOX_PUBLIC_KEY_SIZE);
+
+    return true;
+}
+
+bool tox_messagev2_get_message_alter_id(uint8_t *raw_message, uint8_t *alter_id)
+{
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    if (alter_id == nullptr) {
+        return false;
+    }
+
+    memcpy(alter_id, raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2 + 1, TOX_PUBLIC_KEY_SIZE);
+
+    return true;
+}
+
+bool tox_messagev2_get_sync_message_pubkey(const uint8_t *raw_message, uint8_t *pubkey)
+{
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    if (pubkey == nullptr) {
+        return false;
+    }
+
+    memcpy(pubkey, (raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2), TOX_PUBLIC_KEY_SIZE);
+
+    return true;
+}
+
+uint32_t tox_messagev2_get_sync_message_type(const uint8_t *raw_message)
+{
+    if (raw_message == nullptr) {
+        return UINT32_MAX;
+    }
+
+    uint32_t sync_msg_type;
+    memcpy(&sync_msg_type, (raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE), 4);
+
+    return sync_msg_type;
+}
+
+
+uint8_t tox_messagev2_get_alter_type(uint8_t *raw_message)
+{
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    uint8_t return_value;
+    memcpy(&return_value, raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2, sizeof(return_value));
+
+    // HINT: crude check, that type will be a valid value
+    if (return_value != TOX_MESSAGEV2_ALTER_TYPE_DELETE) {
+        return_value = TOX_MESSAGEV2_ALTER_TYPE_CORRECT;
+    }
+
+    return return_value;
+}
+
+uint32_t tox_messagev2_get_ts_sec(const uint8_t *raw_message)
+{
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    uint32_t return_value;
+    memcpy(&return_value, raw_message + TOX_PUBLIC_KEY_SIZE, sizeof(return_value));
+
+    return return_value;
+}
+
+uint16_t tox_messagev2_get_ts_ms(const uint8_t *raw_message)
+{
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    uint16_t return_value;
+    memcpy(&return_value, raw_message + TOX_PUBLIC_KEY_SIZE + 4, sizeof(return_value));
+
+    return return_value;
+}
+
+bool tox_messagev2_get_sync_message_data(const uint8_t *raw_message, uint32_t raw_message_len,
+        uint8_t *message_text, uint32_t *text_length)
+{
+    bool result = false;
+
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    if (message_text == nullptr) {
+        return false;
+    }
+
+    if (text_length == nullptr) {
+        return false;
+    }
+
+    // HINT: we want at least 1 byte of real message text
+    if (raw_message_len < (TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4 + 1)) {
+        return false;
+    }
+
+    *text_length = (raw_message_len - (TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4));
+    memcpy(message_text, raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4, *text_length);
+
+    return result;
+
+}
+
+bool tox_messagev2_get_message_text(const uint8_t *raw_message, uint32_t raw_message_len,
+                                    bool is_alter_msg,
+                                    uint32_t alter_type, uint8_t *message_text,
+                                    uint32_t *text_length)
+{
+    if (raw_message == nullptr) {
+        return false;
+    }
+
+    if (message_text == nullptr) {
+        return false;
+    }
+
+    if (text_length == nullptr) {
+        return false;
+    }
+
+    if (is_alter_msg == true) {
+        if (alter_type == TOX_MESSAGEV2_ALTER_TYPE_DELETE) {
+            // TODO(zoff): * write me *
+            *text_length = 0;
+            return false;
+        } else { // TOX_MESSAGEV2_ALTER_TYPE_CORRECT
+            // TODO(zoff): * write me *
+            *text_length = 0;
+            return false;
+        }
+    } else { // TOX_FILE_KIND_MESSAGEV2_SEND
+        // HINT: we want at least 1 byte of real message text
+        if (raw_message_len < (TOX_PUBLIC_KEY_SIZE + 4 + 2 + 1)) {
+            return false;
+        }
+
+        *text_length = (raw_message_len - (TOX_PUBLIC_KEY_SIZE + 4 + 2));
+        memcpy(message_text, raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2, *text_length);
+    }
+
+    return true;
+}
+
diff --git a/toxcore/tox.h b/toxcore/tox.h
index ef019e8f5..8dd5c7807 100644
--- a/toxcore/tox.h
+++ b/toxcore/tox.h
@@ -162,6 +162,8 @@ uint32_t tox_version_minor(void);
 
 uint32_t tox_version_patch(void);
 
+#define TOX_HAVE_TOXUTIL               1
+
 //!TOKSTYLE-
 /**
  * @brief A macro to check at preprocessing time whether the client code is
@@ -314,6 +316,32 @@ uint32_t tox_max_message_length(void);
 
 uint32_t tox_max_custom_packet_size(void);
 
+/**
+ * Maximum size of MessageV2 Messagetext
+ */
+#define TOX_MESSAGEV2_MAX_TEXT_LENGTH  4096
+
+uint32_t tox_messagev2_max_text_length(void);
+
+/**
+ * Maximum size of MessageV2 Header
+ */
+#define TOX_MESSAGEV2_MAX_HEADER_SIZE  (TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4)
+
+uint32_t tox_messagev2_max_header_size(void);
+
+/**
+ * Maximum size of MessageV2 Header of non sync messages
+ */
+#define TOX_MESSAGEV2_MAX_NON_SYNC_HEADER_SIZE  (TOX_PUBLIC_KEY_SIZE + 4 + 2 + 1 + TOX_PUBLIC_KEY_SIZE)
+
+/**
+ * Maximum size of MessageV2 Filetransfers (overall size including any overhead)
+ */
+#define TOX_MAX_FILETRANSFER_SIZE_MSGV2 (TOX_MESSAGEV2_MAX_TEXT_LENGTH + TOX_MESSAGEV2_MAX_HEADER_SIZE + TOX_MESSAGEV2_MAX_NON_SYNC_HEADER_SIZE)
+
+uint32_t tox_max_filetransfer_size_msgv2(void);
+
 /**
  * @brief The number of bytes in a hash generated by tox_hash.
  */
@@ -1973,8 +2001,34 @@ enum Tox_File_Kind {
      */
     TOX_FILE_KIND_AVATAR,
 
+    /**
+     * MessageV2 Filetransfers
+     *
+     * filetransfers of this type are always autoaccepted
+     * and the overall size is limited to TOX_MAX_FILETRANSFER_SIZE_MSGV2
+     */
+    TOX_FILE_KIND_MESSAGEV2_SEND = 2,
+
+    /**
+     * TODO: Generate doc
+     */
+    TOX_FILE_KIND_MESSAGEV2_ANSWER = 3,
+
+    /**
+     * TODO: Generate doc
+     */
+    TOX_FILE_KIND_MESSAGEV2_ALTER = 4,
+
+    /**
+     * TODO: Generate doc
+     */
+    TOX_FILE_KIND_MESSAGEV2_SYNC = 5,
 };
 
+typedef enum TOX_MESSAGEV2_ALTER_TYPE {
+    TOX_MESSAGEV2_ALTER_TYPE_DELETE,
+    TOX_MESSAGEV2_ALTER_TYPE_CORRECT,
+} TOX_MESSAGEV2_ALTER_TYPE;
 
 typedef enum Tox_File_Control {
 
@@ -3308,6 +3362,71 @@ uint16_t tox_self_get_udp_port(const Tox *tox, Tox_Err_Get_Port *error);
  */
 uint16_t tox_self_get_tcp_port(const Tox *tox, Tox_Err_Get_Port *error);
 
+
+
+
+/*******************************************************************************
+ *
+ * :: Message V2 functions
+ *
+ ******************************************************************************/
+#define TOX_MESSAGE_V2_ACTIVE 1
+/*
+* sending
+*/
+uint32_t tox_messagev2_size(uint32_t text_length, uint32_t type, uint32_t alter_type);
+
+// wrap a sync message
+//         data_length                  length of the input data
+//         original_sender_pubkey_bin   pubkey of original sender
+//         data_msg_type                type of msg to wrap
+//         raw_data                     input data of the msg to wrap
+//         ts_sec                       unixtimestamp when message was sent (in seconds since epoch)
+//         ts_ms                        unixtimestamp when message was sent (millisecond part)
+//         raw_message                  filled buffer with the wrapped data of the message
+//         msgid                        filled buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
+// return: bool                         true -> if message was wrapped OK
+bool tox_messagev2_sync_wrap(uint32_t data_length, const uint8_t *original_sender_pubkey_bin,
+                             uint32_t data_msg_type,
+                             const uint8_t *raw_data, uint32_t ts_sec,
+                             uint16_t ts_ms, uint8_t *raw_message,
+                             uint8_t *msgid);
+
+// wrap a message
+//         text_length      length of the input text
+//         type             type of msg to wrap
+//         alter_type       alter type of msg to wrap (only if it is an alter msg)
+//         message_text     input text of the msg to wrap
+//         ts_sec           uixtimestamp when message was sent (in seconds since epoch)
+//         ts_ms            unixtimestamp when message was sent (millisecond part)
+//         raw_message      filled buffer with the wrapped data of the message
+//         msgid            filled buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
+// return: bool             true -> if message was wrapped OK
+bool tox_messagev2_wrap(uint32_t text_length, uint32_t type,
+                        uint32_t alter_type,
+                        const uint8_t *message_text, uint32_t ts_sec,
+                        uint16_t ts_ms, uint8_t *raw_message,
+                        uint8_t *msgid);
+/*
+* receiving
+*/
+bool tox_messagev2_get_message_id(const uint8_t *raw_message, uint8_t *msg_id);
+bool tox_messagev2_get_message_alter_id(uint8_t *raw_message, uint8_t *alter_id);
+bool tox_messagev2_get_sync_message_pubkey(const uint8_t *raw_message, uint8_t *pubkey);
+uint32_t tox_messagev2_get_sync_message_type(const uint8_t *raw_message);
+uint8_t tox_messagev2_get_alter_type(uint8_t *raw_message);
+uint32_t tox_messagev2_get_ts_sec(const uint8_t *raw_message);
+uint16_t tox_messagev2_get_ts_ms(const uint8_t *raw_message);
+bool tox_messagev2_get_sync_message_data(const uint8_t *raw_message, uint32_t raw_message_len,
+                                    uint8_t *data, uint32_t *data_length);
+bool tox_messagev2_get_message_text(const uint8_t *raw_message, uint32_t raw_message_len,
+                                    bool is_alter_msg,
+                                    uint32_t alter_type, uint8_t *message_text,
+                                    uint32_t *text_length);
+
+
+
+
 /** @} */
 
 /*******************************************************************************
diff --git a/toxutil/BUILD.bazel b/toxutil/BUILD.bazel
new file mode 100644
index 000000000..a4c7ba055
--- /dev/null
+++ b/toxutil/BUILD.bazel
@@ -0,0 +1,24 @@
+load("//tools:no_undefined.bzl", "cc_library")
+
+filegroup(
+    name = "public_headers",
+    srcs = ["toxutil.h"],
+    visibility = ["//c-toxcore:__pkg__"],
+)
+
+cc_library(
+    name = "public",
+    hdrs = [":public_headers"],
+)
+
+cc_library(
+    name = "toxutil",
+    srcs = ["toxutil.c"],
+    hdrs = ["toxutil.h"],
+    copts = ["-Wno-error"],
+    visibility = ["//c-toxcore:__subpackages__"],
+    deps = [
+        "//c-toxcore/toxcore:Messenger",
+        "//c-toxcore/toxcore:ccompat",
+    ],
+)
diff --git a/toxutil/toxutil.c b/toxutil/toxutil.c
new file mode 100644
index 000000000..3f5f4ee95
--- /dev/null
+++ b/toxutil/toxutil.c
@@ -0,0 +1,1584 @@
+/*
+ * Copyright © 2018 Zoff
+ *
+ * This file is part of Tox, the free peer to peer instant messenger.
+ *
+ * Tox is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Tox is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+//!TOKSTYLE-
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wpragmas"
+#pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wmissing-variable-declarations"
+
+#include <time.h>
+
+#include "../toxcore/Messenger.h"
+
+#include "../toxcore/logger.h"
+#include "../toxcore/mono_time.h"
+#include "../toxcore/network.h"
+#include "../toxcore/util.h"
+#include "../toxcore/tox.h"
+#include "toxutil.h"
+
+#include <assert.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+
+#define CAP_PACKET_ID 170
+#define CAP_BYTE_0 33
+#define CAP_BYTE_1 44
+
+// #define TOX_UTIL_EXPIRE_FT_MS 50000 // msgV2 FTs should expire after 50 seconds
+
+typedef struct tox_utils_Node {
+    uint8_t key[TOX_PUBLIC_KEY_SIZE];
+    uint32_t key2;
+    void *data;
+    struct tox_utils_Node *next;
+} tox_utils_Node;
+
+typedef struct tox_utils_List {
+    uint32_t size;
+    tox_utils_Node *head;
+} tox_utils_List;
+
+
+static tox_utils_List global_friend_capability_list;
+
+typedef struct global_friend_capability_entry {
+    bool msgv2_cap;
+} global_friend_capability_entry;
+
+
+static tox_utils_List global_msgv2_incoming_ft_list;
+
+typedef struct global_msgv2_incoming_ft_entry {
+    uint32_t friend_number;
+    uint32_t file_number;
+    uint32_t kind;
+    uint64_t file_size;
+    uint32_t timestamp;
+    uint8_t msg_data[TOX_MAX_FILETRANSFER_SIZE_MSGV2];
+} global_msgv2_incoming_ft_entry;
+
+
+static tox_utils_List global_msgv2_outgoing_ft_list;
+
+typedef struct global_msgv2_outgoing_ft_entry {
+    uint32_t friend_number;
+    uint32_t file_number;
+    uint32_t kind;
+    uint64_t file_size;
+    uint32_t timestamp;
+    uint8_t msg_data[TOX_MAX_FILETRANSFER_SIZE_MSGV2];
+} global_msgv2_outgoing_ft_entry;
+
+static uint16_t global_ts_ms = 0;
+static pthread_mutex_t mutex_tox_util[1];
+
+// ------------ UTILS ------------
+
+#if 0
+static time_t get_unix_time(void)
+{
+    return time(NULL);
+}
+#endif
+
+#if 0
+/* Returns 1 if timed out, 0 otherwise */
+static int timed_out(time_t timestamp, time_t timeout)
+{
+    return timestamp + timeout <= get_unix_time();
+}
+#endif
+
+/* compares 2 items of length len (e.g.: Tox Pubkeys)
+   Returns 0 if they are the same, 1 if they differ
+ */
+static int check_file_signature(const uint8_t *pubkey1, const uint8_t *pubkey2, size_t len)
+{
+    int ret = memcmp(pubkey1, pubkey2, len);
+    return ret == 0 ? 0 : 1;
+}
+
+
+#if 0
+/**
+ * @fn
+ * get_hex
+ *
+ * @brief
+ * Converts a char into binary string
+ *
+ * @param[in]
+ *     buf Value to be converted to hex string
+ * @param[in]
+ *     buf_len Length of the buffer
+ * @param[in]
+ *     hex_ Pointer to space to put Hex string into
+ * @param[in]
+ *     hex_len Length of the hex string space
+ * @param[in]
+ *     num_col Number of columns in display hex string
+ */
+static inline void
+get_hex(char *buf, int buf_len, char *hex_, int hex_len, int num_col)
+{
+    int i;
+#define ONE_BYTE_HEX_STRING_SIZE   3
+    unsigned int byte_no = 0;
+
+    if (buf_len <= 0) {
+        if (hex_len > 0) {
+            hex_[0] = '\0';
+        }
+
+        return;
+    }
+
+    if (hex_len < ONE_BYTE_HEX_STRING_SIZE + 1) {
+        return;
+    }
+
+    do {
+        for (i = 0; ((i < num_col) && (buf_len > 0) && (hex_len > 0)); ++i) {
+            snprintf(hex_, hex_len, "%02X ", buf[byte_no++] & 0xff);
+            hex_ += ONE_BYTE_HEX_STRING_SIZE;
+            hex_len -= ONE_BYTE_HEX_STRING_SIZE;
+            buf_len--;
+        }
+
+        if (buf_len > 1) {
+            snprintf(hex_, hex_len, "\n");
+            hex_ += 1;
+        }
+    } while ((buf_len) > 0 && (hex_len > 0));
+
+}
+#endif
+
+
+
+static void tox_utils_list_init(tox_utils_List *l)
+{
+    pthread_mutex_lock(mutex_tox_util);
+    l->size = 0;
+    l->head = NULL;
+    pthread_mutex_unlock(mutex_tox_util);
+}
+
+static void tox_utils_list_clear(tox_utils_List *l)
+{
+    pthread_mutex_lock(mutex_tox_util);
+
+    tox_utils_Node *head = l->head;
+    tox_utils_Node *next_ = NULL;
+
+    while (head) {
+        next_ = head->next;
+
+        l->size--;
+        l->head = next_;
+
+        if (head->data) {
+            free(head->data);
+        }
+
+        free(head);
+        head = next_;
+    }
+
+    l->size = 0;
+    l->head = NULL;
+
+    pthread_mutex_unlock(mutex_tox_util);
+}
+
+
+static void tox_utils_list_add(tox_utils_List *l, uint8_t *key, uint32_t key2, void *data)
+{
+    pthread_mutex_lock(mutex_tox_util);
+
+    tox_utils_Node *n = calloc(1, sizeof(tox_utils_Node));
+
+    memcpy(n->key, key, TOX_PUBLIC_KEY_SIZE);
+    n->key2 = key2;
+    n->data = data;
+
+    if (l->head == NULL) {
+        n->next = NULL;
+    } else {
+        n->next = l->head;
+    }
+
+    l->head = n;
+    l->size++;
+
+    pthread_mutex_unlock(mutex_tox_util);
+}
+
+static tox_utils_Node *tox_utils_list_get(tox_utils_List *l, uint8_t *key, uint32_t key2)
+{
+    pthread_mutex_lock(mutex_tox_util);
+
+    tox_utils_Node *head = l->head;
+
+    while (head) {
+        if (head->key2 == key2) {
+            if (check_file_signature(head->key, key, TOX_PUBLIC_KEY_SIZE) == 0) {
+                pthread_mutex_unlock(mutex_tox_util);
+                return head;
+            }
+        }
+
+        head = head->next;
+    }
+
+    pthread_mutex_unlock(mutex_tox_util);
+    return NULL;
+}
+
+static void tox_utils_list_remove_single_node(tox_utils_List *l, tox_utils_Node *n, tox_utils_Node *n_minus_1)
+{
+    if (!l) {
+        return;
+    }
+
+    if (!n) {
+        return;
+    }
+
+    if (n_minus_1 == NULL) {
+        // want to delete the first node
+        l->head = n->next;
+
+        if (n->data) {
+            free(n->data);
+        }
+
+        free(n);
+        l->size--;
+        n = NULL;
+        return;
+    } else {
+        n_minus_1->next = n->next;
+
+        if (n->data) {
+            free(n->data);
+        }
+
+        free(n);
+        l->size--;
+        n = NULL;
+    }
+
+}
+
+static void tox_utils_list_remove(tox_utils_List *l, uint8_t *key, uint32_t key2)
+{
+    pthread_mutex_lock(mutex_tox_util);
+
+    tox_utils_Node *head = l->head;
+    tox_utils_Node *prev_ = NULL;
+    tox_utils_Node *next_ = NULL;
+
+    while (head) {
+        next_ = head->next;
+
+        if (head->key2 == key2) {
+            if (check_file_signature(head->key, key, TOX_PUBLIC_KEY_SIZE) == 0) {
+                tox_utils_list_remove_single_node(l, head, prev_);
+                // start from beginning of the list
+                head = l->head;
+                prev_ = NULL;
+                next_ = NULL;
+                continue;
+            }
+        }
+
+        prev_ = head;
+        head = next_;
+    }
+
+    pthread_mutex_unlock(mutex_tox_util);
+}
+
+static void tox_utils_list_remove_2(tox_utils_List *l, uint8_t *key)
+{
+    pthread_mutex_lock(mutex_tox_util);
+
+    tox_utils_Node *head = l->head;
+    tox_utils_Node *prev_ = NULL;
+    tox_utils_Node *next_ = NULL;
+
+    while (head) {
+        next_ = head->next;
+
+        if (check_file_signature(head->key, key, TOX_PUBLIC_KEY_SIZE) == 0) {
+            tox_utils_list_remove_single_node(l, head, prev_);
+            // start from beginning of the list
+            head = l->head;
+            prev_ = NULL;
+            next_ = NULL;
+            continue;
+        }
+
+        prev_ = head;
+        head = next_;
+    }
+
+    pthread_mutex_unlock(mutex_tox_util);
+}
+
+// ------------ UTILS ------------
+
+
+
+
+
+
+
+
+
+
+
+
+
+// ----------- FUNCS -----------
+#if 0
+static int64_t tox_utils_pubkey_to_friendnum(Tox *tox, const uint8_t *public_key)
+{
+    TOX_ERR_FRIEND_BY_PUBLIC_KEY error;
+    uint32_t fnum = tox_friend_by_public_key(tox, public_key, &error);
+
+    if (error == 0) {
+        return (int64_t)fnum;
+    } else {
+        return -1;
+    }
+}
+#endif
+
+static bool tox_utils_friendnum_to_pubkey(Tox *tox, uint8_t *public_key, uint32_t friend_number)
+{
+    TOX_ERR_FRIEND_GET_PUBLIC_KEY error;
+    return tox_friend_get_public_key(tox, friend_number, public_key, &error);
+}
+
+static bool tox_utils_get_capabilities(Tox *tox, uint32_t friendnumber)
+{
+
+    uint64_t capabilities = tox_friend_get_capabilities(tox, friendnumber);
+    if ((capabilities & TOX_CAPABILITY_MSGV2) == TOX_CAPABILITY_MSGV2)
+    {
+        // Messenger *m;
+        // m = *(Messenger **)tox;
+        // LOGGER_WARNING(m->log, "toxutil:get_capabilities(from online packet)");
+        return true;
+    }
+
+    uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+    if (friend_pubkey) {
+        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friendnumber);
+
+        if (res == true) {
+            tox_utils_Node *n = tox_utils_list_get(&global_friend_capability_list, friend_pubkey, 0);
+
+            if (n != NULL) {
+                free(friend_pubkey);
+                return ((global_friend_capability_entry *)(n->data))->msgv2_cap;
+            }
+        }
+
+        free(friend_pubkey);
+    }
+
+    return false;
+}
+
+static void tox_utils_set_capabilities(Tox *tox, uint32_t friendnumber, bool cap)
+{
+    uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+    if (friend_pubkey) {
+        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friendnumber);
+
+        if (res == true) {
+            global_friend_capability_entry *data = calloc(1, sizeof(global_friend_capability_entry));
+            data->msgv2_cap = cap;
+
+            tox_utils_Node *n = tox_utils_list_get(&global_friend_capability_list, friend_pubkey, 0);
+
+            if (n == NULL) {
+                if (cap == true) {
+                    tox_utils_list_add(&global_friend_capability_list, friend_pubkey, 0, data);
+                    // TODO(iphydf): Don't rely on toxcore internals.
+                    Messenger *m;
+                    m = *(Messenger **)tox;
+                    LOGGER_WARNING(m->log, "toxutil:set_capabilities(add:1)");
+                }
+            } else {
+                tox_utils_list_remove(&global_friend_capability_list, friend_pubkey, 0);
+                Messenger *m = *(Messenger **)tox;
+                LOGGER_WARNING(m->log, "toxutil:set_capabilities(rm)");
+
+                if (cap == true) {
+                    tox_utils_list_add(&global_friend_capability_list, friend_pubkey, 0, data);
+                    Messenger *m2 = *(Messenger **)tox;
+                    LOGGER_WARNING(m2->log, "toxutil:set_capabilities(add:2)");
+                }
+            }
+        }
+
+        free(friend_pubkey);
+    }
+}
+
+static void tox_utils_send_capabilities(Tox *tox, uint32_t friendnumber)
+{
+    uint8_t data[3];
+    data[0] = CAP_PACKET_ID; // packet ID
+    data[1] = CAP_BYTE_0;
+    data[2] = CAP_BYTE_1;
+    TOX_ERR_FRIEND_CUSTOM_PACKET error;
+    tox_friend_send_lossless_packet(tox, friendnumber, data, 3, &error);
+
+    if (error == TOX_ERR_FRIEND_CUSTOM_PACKET_SENDQ) {
+        Messenger *m = *(Messenger **)tox;
+        LOGGER_WARNING(m->log, "toxutil:tox_utils_send_capabilities fnum=%d error:TOX_ERR_FRIEND_CUSTOM_PACKET_SENDQ",
+                       (int)friendnumber);
+    } else if (error != 0) {
+        Messenger *m = *(Messenger **)tox;
+        LOGGER_WARNING(m->log, "toxutil:tox_utils_send_capabilities fnum=%d errnum:%d",
+                       (int)friendnumber, (int)error);
+    }
+}
+
+static void tox_utils_receive_capabilities(Tox *tox, uint32_t friendnumber, const uint8_t *data,
+        size_t length)
+{
+    if (length == 3) {
+        if ((data[0] == CAP_PACKET_ID) && (data[1] == CAP_BYTE_0) && (data[2] == CAP_BYTE_1)) {
+            Messenger *m = *(Messenger **)tox;
+            LOGGER_WARNING(m->log, "toxutil:receive_capabilities fnum=%d data=%d% d %d",
+                           (int)friendnumber, (int)data[0], (int)data[1], (int)data[2]);
+
+            // friend has message V2 capability
+            tox_utils_set_capabilities(tox, friendnumber, true);
+        }
+    }
+}
+
+static void tox_utils_housekeeping(Tox *tox)
+{
+#if 0
+
+    pthread_mutex_lock(mutex_tox_util);
+
+    // cancel and clear old outgoing FTs ----------------
+    tox_utils_List *l = &global_msgv2_outgoing_ft_list;
+
+    tox_utils_Node *head = l->head;
+    tox_utils_Node *next_ = NULL;
+
+    while (head) {
+        next_ = head->next;
+
+        if (head->data) {
+            global_msgv2_outgoing_ft_entry *e = ((global_msgv2_outgoing_ft_entry *)(head->data));
+
+            Messenger *m = *(Messenger **)tox;
+
+            if ((e->timestamp + TOX_UTIL_EXPIRE_FT_MS) < current_time_monotonic(m->mono_time)) {
+                // cancel FT
+                uint32_t friend_number = e->friend_number;
+                uint32_t file_number = e->file_number;
+
+                bool res = tox_file_control(tox, friend_number, file_number,
+                                            (TOX_FILE_CONTROL)TOX_FILE_CONTROL_CANCEL, NULL);
+
+                if (res == true) {
+                    // remove FT from list
+                    if (head->data) {
+                        free(head->data);
+                    }
+
+                    l->size--;
+                    l->head = next_;
+                    free(head);
+
+                    break;
+                }
+            }
+        }
+
+        l->head = next_;
+        head = next_;
+    }
+
+    // cancel and clear old outgoing FTs ----------------
+
+
+
+    // cancel and clear old incoming FTs ----------------
+    l = &global_msgv2_incoming_ft_list;
+
+    head = l->head;
+    next_ = NULL;
+
+    while (head) {
+        next_ = head->next;
+
+        if (head->data) {
+            global_msgv2_incoming_ft_entry *e = ((global_msgv2_incoming_ft_entry *)(head->data));
+
+            Messenger *m = *(Messenger **)tox;
+
+            if ((e->timestamp + TOX_UTIL_EXPIRE_FT_MS) < current_time_monotonic(m->mono_time)) {
+                // cancel FT
+                uint32_t friend_number = e->friend_number;
+                uint32_t file_number = e->file_number;
+
+                bool res = tox_file_control(tox, friend_number, file_number,
+                                            (TOX_FILE_CONTROL)TOX_FILE_CONTROL_CANCEL, NULL);
+
+                if (res == true) {
+                    // remove FT from list
+                    if (head->data) {
+                        free(head->data);
+                    }
+
+                    l->size--;
+                    l->head = next_;
+                    free(head);
+
+                    break;
+                }
+            }
+        }
+
+        l->head = next_;
+        head = next_;
+    }
+
+    pthread_mutex_unlock(mutex_tox_util);
+
+    // cancel and clear old incoming FTs ----------------
+#endif
+}
+
+// ----------- FUNCS -----------
+
+
+
+
+// --- set callbacks ---
+void (*tox_utils_selfconnectionstatus)(struct Tox *tox, unsigned int, void *);
+
+void tox_utils_callback_self_connection_status(Tox *tox, tox_self_connection_status_cb *callback)
+{
+    tox_utils_selfconnectionstatus = (void (*)(Tox * tox,
+                                      unsigned int, void *))callback;
+}
+
+
+void (*tox_utils_friend_connectionstatuschange)(struct Tox *tox, uint32_t,
+        unsigned int, void *);
+
+void tox_utils_callback_friend_connection_status(Tox *tox, tox_friend_connection_status_cb *callback)
+{
+    tox_utils_friend_connectionstatuschange = (void (*)(Tox * tox, uint32_t,
+            unsigned int, void *))callback;
+    Messenger *m = *(Messenger **)tox;
+    LOGGER_WARNING(m->log, "toxutil:set callback");
+}
+
+
+void (*tox_utils_friend_losslesspacket)(struct Tox *tox, uint32_t, const uint8_t *,
+                                        size_t, void *);
+
+void tox_utils_callback_friend_lossless_packet(Tox *tox, tox_friend_lossless_packet_cb *callback)
+{
+    tox_utils_friend_losslesspacket = (void (*)(Tox * tox, uint32_t,
+                                       const uint8_t *, size_t, void *))callback;
+}
+
+
+void (*tox_utils_filerecvcontrol)(struct Tox *tox, uint32_t, uint32_t,
+                                  unsigned int, void *);
+
+void tox_utils_callback_file_recv_control(Tox *tox, tox_file_recv_control_cb *callback)
+{
+    tox_utils_filerecvcontrol = (void (*)(Tox * tox, uint32_t, uint32_t,
+                                          unsigned int, void *))callback;
+}
+
+void (*tox_utils_filechunkrequest)(struct Tox *tox, uint32_t, uint32_t,
+                                   uint64_t, size_t, void *);
+
+void tox_utils_callback_file_chunk_request(Tox *tox, tox_file_chunk_request_cb *callback)
+{
+    tox_utils_filechunkrequest = (void (*)(Tox * tox, uint32_t, uint32_t,
+                                           uint64_t, size_t, void *))callback;
+}
+
+void (*tox_utils_filerecv)(struct Tox *tox, uint32_t, uint32_t,
+                           uint32_t, uint64_t, const uint8_t *, size_t, void *) = NULL;
+
+void tox_utils_callback_file_recv(Tox *tox, tox_file_recv_cb *callback)
+{
+    tox_utils_filerecv = (void (*)(Tox * tox, uint32_t, uint32_t,
+                                   uint32_t, uint64_t, const uint8_t *, size_t, void *))callback;
+}
+
+void (*tox_utils_filerecvchunk)(struct Tox *tox, uint32_t, uint32_t, uint64_t,
+                                const uint8_t *, size_t, void *);
+
+
+void tox_utils_callback_file_recv_chunk(Tox *tox, tox_file_recv_chunk_cb *callback)
+{
+    tox_utils_filerecvchunk = (void (*)(Tox * tox, uint32_t, uint32_t, uint64_t,
+                                        const uint8_t *, size_t, void *))callback;
+}
+
+void (*tox_utils_friend_message_v2)(struct Tox *tox, uint32_t, const uint8_t *,
+                                    size_t);
+
+void tox_utils_callback_friend_message_v2(Tox *tox, tox_util_friend_message_v2_cb *callback)
+{
+    tox_utils_friend_message_v2 = (void (*)(Tox * tox, uint32_t, const uint8_t *,
+                                            size_t))callback;
+}
+
+void (*tox_utils_friend_sync_message_v2)(struct Tox *tox, uint32_t, const uint8_t *,
+        size_t);
+
+void tox_utils_callback_friend_sync_message_v2(Tox *tox, tox_util_friend_sync_message_v2_cb *callback)
+{
+    tox_utils_friend_sync_message_v2 = (void (*)(Tox * tox, uint32_t, const uint8_t *,
+                                        size_t))callback;
+}
+
+void (*tox_utils_friend_read_receipt_message_v2)(struct Tox *tox, uint32_t, uint32_t,
+        const uint8_t *);
+
+void tox_utils_callback_friend_read_receipt_message_v2(Tox *tox,
+        tox_utils_friend_read_receipt_message_v2_cb *callback)
+{
+    tox_utils_friend_read_receipt_message_v2 = (void (*)(Tox * tox, uint32_t, uint32_t,
+            const uint8_t *))callback;
+}
+
+
+Tox *tox_utils_new(const struct Tox_Options *options, TOX_ERR_NEW *error)
+{
+    if (pthread_mutex_init(mutex_tox_util, NULL) != 0) {
+        if (error) {
+            // TODO: find a better error code, use malloc error for now
+            *error = TOX_ERR_NEW_MALLOC;
+        }
+
+        return NULL;
+    }
+
+    tox_utils_list_init(&global_friend_capability_list);
+    tox_utils_list_init(&global_msgv2_incoming_ft_list);
+    tox_utils_list_init(&global_msgv2_outgoing_ft_list);
+
+    // ATTENTION: we only have a mono_time instance after this call returns!!
+    return tox_new(options, error);
+}
+
+void tox_utils_kill(Tox *tox)
+{
+    tox_utils_list_clear(&global_friend_capability_list);
+    tox_utils_list_clear(&global_msgv2_incoming_ft_list);
+    tox_utils_list_clear(&global_msgv2_outgoing_ft_list);
+
+    tox_kill(tox);
+
+    pthread_mutex_destroy(mutex_tox_util);
+}
+
+bool tox_utils_friend_delete(Tox *tox, uint32_t friend_number, TOX_ERR_FRIEND_DELETE *error)
+{
+    // clear all FTs of this friend from incmoning/outgoing FT lists
+    uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+    if (friend_pubkey) {
+        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+        if (res == true) {
+            tox_utils_list_remove_2(&global_msgv2_incoming_ft_list, friend_pubkey);
+            tox_utils_list_remove_2(&global_msgv2_outgoing_ft_list, friend_pubkey);
+        }
+
+        free(friend_pubkey);
+    }
+
+    return tox_friend_delete(tox, friend_number, error);
+}
+
+// --- set callbacks ---
+
+
+
+void tox_utils_friend_lossless_packet_cb(Tox *tox, uint32_t friend_number, const uint8_t *data,
+        size_t length, void *user_data)
+{
+    // ------- do messageV2 stuff -------
+    tox_utils_receive_capabilities(tox, friend_number, data, length);
+    // ------- do messageV2 stuff -------
+
+    // ------- call the real CB function -------
+    if (tox_utils_friend_losslesspacket) {
+        tox_utils_friend_losslesspacket(tox, friend_number, data, length, user_data);
+    }
+
+    // ------- call the real CB function -------
+}
+
+
+void tox_utils_self_connection_status_cb(Tox *tox,
+        TOX_CONNECTION connection_status, void *user_data)
+{
+    // ------- do messageV2 stuff -------
+    if (connection_status == TOX_CONNECTION_NONE) {
+        // if we go offline ourselves, remove all FT data
+        tox_utils_list_clear(&global_msgv2_incoming_ft_list);
+        tox_utils_list_clear(&global_msgv2_outgoing_ft_list);
+    }
+
+    // ------- do messageV2 stuff -------
+
+    // ------- call the real CB function -------
+    if (tox_utils_selfconnectionstatus) {
+        tox_utils_selfconnectionstatus(tox, connection_status, user_data);
+        // Messenger *m = (Messenger *)tox;
+        // LOGGER_WARNING(m->log, "toxutil:selfconnectionstatus");
+    }
+
+    // ------- call the real CB function -------
+}
+
+
+void tox_utils_friend_connection_status_cb(Tox *tox, uint32_t friendnumber,
+        TOX_CONNECTION connection_status, void *user_data)
+{
+    // ------- do messageV2 stuff -------
+    if (connection_status == TOX_CONNECTION_NONE) {
+        tox_utils_set_capabilities(tox, friendnumber, false);
+
+        // remove FT data from list
+        uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+        if (friend_pubkey) {
+            bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friendnumber);
+
+            if (res == true) {
+                tox_utils_list_remove_2(&global_msgv2_incoming_ft_list, friend_pubkey);
+                tox_utils_list_remove_2(&global_msgv2_outgoing_ft_list, friend_pubkey);
+            }
+
+            free(friend_pubkey);
+        }
+    } else {
+        tox_utils_send_capabilities(tox, friendnumber);
+    }
+
+    // ------- do messageV2 stuff -------
+
+    // ------- call the real CB function -------
+    if (tox_utils_friend_connectionstatuschange) {
+        tox_utils_friend_connectionstatuschange(tox, friendnumber, connection_status, user_data);
+        // Messenger *m = (Messenger *)tox;
+        // LOGGER_WARNING(m->log, "toxutil:friend_connectionstatuschange");
+    }
+
+    // ------- call the real CB function -------
+}
+
+
+void tox_utils_file_recv_control_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
+                                    TOX_FILE_CONTROL control, void *user_data)
+{
+    // ------- do messageV2 stuff -------
+    if (control == TOX_FILE_CONTROL_CANCEL) {
+        uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+        if (friend_pubkey) {
+            bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+            if (res == true) {
+                tox_utils_Node *n = tox_utils_list_get(&global_msgv2_outgoing_ft_list,
+                                                       friend_pubkey, file_number);
+
+                if (n != NULL) {
+                    if (
+                        (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SEND)
+                        ||
+                        (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_ANSWER)
+                        ||
+                        (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SYNC)
+                    ) {
+                        // remove FT data from list
+                        tox_utils_list_remove(&global_msgv2_outgoing_ft_list,
+                                              friend_pubkey, file_number);
+
+                        free(friend_pubkey);
+                        return;
+                    }
+                }
+
+                n = tox_utils_list_get(&global_msgv2_incoming_ft_list,
+                                       friend_pubkey, file_number);
+
+                if (n != NULL) {
+                    if (
+                        (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SEND)
+                        ||
+                        (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_ANSWER)
+                        ||
+                        (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SYNC)
+                    ) {
+                        // remove FT data from list
+                        tox_utils_list_remove(&global_msgv2_incoming_ft_list,
+                                              friend_pubkey, file_number);
+
+                        free(friend_pubkey);
+                        return;
+                    }
+                }
+
+            }
+
+            free(friend_pubkey);
+        }
+    }
+
+    // ------- do messageV2 stuff -------
+
+    // ------- call the real CB function -------
+    if (tox_utils_filerecvcontrol) {
+        tox_utils_filerecvcontrol(tox, friend_number, file_number, control, user_data);
+        // Messenger *m = (Messenger *)tox;
+        // LOGGER_WARNING(m->log, "toxutil:file_recv_control_cb");
+    }
+
+    // ------- call the real CB function -------
+}
+
+
+void tox_utils_file_chunk_request_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
+                                     uint64_t position, size_t length, void *user_data)
+{
+    // ------- do messageV2 stuff -------
+    uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+    if (friend_pubkey) {
+        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+        if (res == true) {
+            tox_utils_Node *n = tox_utils_list_get(&global_msgv2_outgoing_ft_list,
+                                                   friend_pubkey, file_number);
+
+            if (n != NULL) {
+                if (
+                    (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SEND)
+                    ||
+                    (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_ANSWER)
+                    ||
+                    (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SYNC)
+                ) {
+                    if (length == 0) {
+                        // FT finished
+                        // remove FT data from list
+                        tox_utils_list_remove(&global_msgv2_outgoing_ft_list,
+                                              friend_pubkey, file_number);
+                    } else {
+                        uint8_t *data_ = ((uint8_t *)((global_msgv2_outgoing_ft_entry *)(n->data))->msg_data);
+                        uint64_t filesize = ((global_msgv2_outgoing_ft_entry *)(n->data))->file_size;
+                        const uint8_t *data = (const uint8_t *)(data_ + position);
+
+                        if (position >= filesize) {
+                            free(friend_pubkey);
+                            return;
+                        }
+
+                        TOX_ERR_FILE_SEND_CHUNK error_send_chunk;
+                        bool result = tox_file_send_chunk(tox, friend_number,
+                                                          file_number,
+                                                          position, data,
+                                                          length, &error_send_chunk);
+                    }
+
+                    free(friend_pubkey);
+                    return;
+                }
+            }
+        }
+
+        free(friend_pubkey);
+    }
+
+    // ------- do messageV2 stuff -------
+
+    // ------- call the real CB function -------
+    if (tox_utils_filechunkrequest) {
+        tox_utils_filechunkrequest(tox, friend_number, file_number, position, length, user_data);
+        // Messenger *m = (Messenger *)tox;
+        // LOGGER_WARNING(m->log, "toxutil:file_recv_control_cb");
+    }
+
+    // ------- call the real CB function -------
+}
+
+void tox_utils_file_recv_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
+                            uint32_t kind, uint64_t file_size,
+                            const uint8_t *filename, size_t filename_length, void *user_data)
+{
+    // ------- do messageV2 stuff -------
+    if (
+        (kind == TOX_FILE_KIND_MESSAGEV2_SEND)
+        ||
+        (kind == TOX_FILE_KIND_MESSAGEV2_ANSWER)
+        ||
+        (kind == TOX_FILE_KIND_MESSAGEV2_SYNC)
+    ) {
+        global_msgv2_incoming_ft_entry *data = calloc(1, sizeof(global_msgv2_incoming_ft_entry));
+
+        if (data) {
+            data->friend_number = friend_number;
+            data->file_number = file_number;
+            data->kind = kind;
+            data->file_size = file_size;
+            Messenger *m = *(Messenger **)tox;
+            data->timestamp = current_time_monotonic(m->mono_time);
+
+            uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+            if (friend_pubkey) {
+                bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+                if (res == true) {
+                    tox_utils_housekeeping(tox);
+                    tox_utils_list_add(&global_msgv2_incoming_ft_list, friend_pubkey,
+                                       file_number, data);
+                    // Messenger *m = (Messenger *)tox;
+                    // LOGGER_WARNING(m->log, "toxutil:file_recv_cb:TOX_FILE_KIND_MESSAGEV2_SEND:%d:%d",
+                    //               (int)friend_number, (int)file_number);
+                }
+
+                free(friend_pubkey);
+            } else {
+                free(data);
+            }
+        }
+
+        return;
+    } else if (kind == TOX_FILE_KIND_MESSAGEV2_ALTER) {
+    } else {
+        // ------- do messageV2 stuff -------
+
+        // ------- call the real CB function -------
+        if (tox_utils_filerecv) {
+            tox_utils_filerecv(tox, friend_number, file_number, kind, file_size,
+                               filename, filename_length, user_data);
+            // Messenger *m = (Messenger *)tox;
+            // LOGGER_WARNING(m->log, "toxutil:file_recv_cb");
+        }
+
+        // ------- call the real CB function -------
+    }
+}
+
+void tox_utils_file_recv_chunk_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
+                                  uint64_t position, const uint8_t *data, size_t length,
+                                  void *user_data)
+{
+    // ------- do messageV2 stuff -------
+    uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+    if (friend_pubkey) {
+        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+        if (res == true) {
+            tox_utils_Node *n = tox_utils_list_get(&global_msgv2_incoming_ft_list,
+                                                   friend_pubkey, file_number);
+
+            if (n != NULL) {
+                if (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SEND) {
+                    if (length == 0) {
+                        // FT finished
+                        if (tox_utils_friend_message_v2) {
+                            const uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)
+                                                                (n->data))->msg_data);
+                            const uint64_t size_ = ((global_msgv2_incoming_ft_entry *)
+                                                    (n->data))->file_size;
+                            tox_utils_friend_message_v2(tox, friend_number, data_, (size_t)size_);
+                        }
+
+                        // remove FT data from list
+                        tox_utils_list_remove(&global_msgv2_incoming_ft_list,
+                                              friend_pubkey, file_number);
+                    } else {
+                        // copy chunk into buffer
+                        uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)(n->data))->msg_data);
+                        memcpy((data_ + position), data, length);
+                    }
+
+                    free(friend_pubkey);
+                    return;
+                } else if (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SYNC) {
+                    if (length == 0) {
+                        // FT finished
+                        if (tox_utils_friend_sync_message_v2) {
+                            const uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)
+                                                                (n->data))->msg_data);
+                            const uint64_t size_ = ((global_msgv2_incoming_ft_entry *)
+                                                    (n->data))->file_size;
+                            tox_utils_friend_sync_message_v2(tox, friend_number, data_, (size_t)size_);
+                        }
+
+                        // remove FT data from list
+                        tox_utils_list_remove(&global_msgv2_incoming_ft_list,
+                                              friend_pubkey, file_number);
+                    } else {
+                        // copy chunk into buffer
+                        uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)(n->data))->msg_data);
+                        memcpy((data_ + position), data, length);
+                    }
+
+                    free(friend_pubkey);
+                    return;
+                } else if (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_ANSWER) {
+                    if (length == 0) {
+                        // FT finished
+                        if (tox_utils_friend_read_receipt_message_v2) {
+                            const uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)
+                                                                (n->data))->msg_data);
+                            const uint64_t size_ = ((global_msgv2_incoming_ft_entry *)
+                                                    (n->data))->file_size;
+
+                            uint32_t answer_raw_size = tox_messagev2_size(0,
+                                                       TOX_FILE_KIND_MESSAGEV2_ANSWER,
+                                                       0);
+
+                            if (size_ >= answer_raw_size) {
+
+                                const uint32_t ts_sec_ = tox_messagev2_get_ts_sec(data_);
+                                uint8_t *msgid_ = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+                                if (msgid_) {
+                                    bool res1 = tox_messagev2_get_message_id(data_, msgid_);
+
+                                    if (res1 == true) {
+                                        tox_utils_friend_read_receipt_message_v2(tox, friend_number,
+                                                ts_sec_, (const uint8_t *)msgid_);
+                                    }
+
+                                    free(msgid_);
+                                }
+                            }
+
+                        }
+
+                        // remove FT data from list
+                        tox_utils_list_remove(&global_msgv2_incoming_ft_list,
+                                              friend_pubkey, file_number);
+                    } else {
+                        // copy chunk into buffer
+                        uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)(n->data))->msg_data);
+                        memcpy((data_ + position), data, length);
+                    }
+
+                    free(friend_pubkey);
+                    return;
+                }
+
+
+            }
+        }
+
+        free(friend_pubkey);
+    }
+
+    // ------- do messageV2 stuff -------
+
+    // ------- call the real CB function -------
+    if (tox_utils_filerecvchunk) {
+        tox_utils_filerecvchunk(tox, friend_number, file_number,
+                                position, data, length, user_data);
+        // Messenger *m = (Messenger *)tox;
+        // LOGGER_WARNING(m->log, "toxutil:file_recv_chunk_cb");
+    }
+
+    // ------- call the real CB function -------
+}
+
+
+bool tox_util_friend_send_msg_receipt_v2(Tox *tox, uint32_t friend_number, uint8_t *msgid, uint32_t ts_sec)
+{
+    if (msgid) {
+        bool friend_has_msgv2 = tox_utils_get_capabilities(tox, friend_number);
+
+        // DEBUG ==========================
+        // DEBUG ==========================
+        // friend_has_msgv2 = true;
+        // DEBUG ==========================
+        // DEBUG ==========================
+
+        if (friend_has_msgv2 == true) {
+            uint32_t raw_msg_len = tox_messagev2_size(0, (uint32_t)TOX_FILE_KIND_MESSAGEV2_ANSWER, 0);
+            uint8_t *raw_message = calloc(1, (size_t)raw_msg_len);
+
+            if (!raw_message) {
+                return false;
+            }
+
+            bool result = tox_messagev2_wrap(0,
+                                             (uint32_t)TOX_FILE_KIND_MESSAGEV2_ANSWER,
+                                             0,
+                                             NULL, ts_sec,
+                                             0,
+                                             raw_message,
+                                             msgid);
+
+            if (result == true) {
+                // ok we have our raw message in "raw_message" and the length in "raw_msg_len"
+                // now send it
+                const char *filename = "messagev2ack.txt";
+                TOX_ERR_FILE_SEND error_send;
+                uint32_t file_num_new = tox_file_send(tox, friend_number,
+                                                      (uint32_t)TOX_FILE_KIND_MESSAGEV2_ANSWER,
+                                                      (uint64_t)raw_msg_len, (const uint8_t *)msgid,
+                                                      (const uint8_t *)filename, (size_t)strlen(filename),
+                                                      &error_send);
+
+                if ((file_num_new == UINT32_MAX) || (error_send != TOX_ERR_FILE_SEND_OK)) {
+                    free(raw_message);
+                    return false;
+                }
+
+                global_msgv2_outgoing_ft_entry *data = calloc(1, sizeof(global_msgv2_outgoing_ft_entry));
+
+                if (data) {
+                    data->friend_number = friend_number;
+                    data->file_number = file_num_new;
+                    data->kind = TOX_FILE_KIND_MESSAGEV2_ANSWER;
+                    data->file_size = raw_msg_len;
+                    Messenger *m = *(Messenger **)tox;
+                    data->timestamp = current_time_monotonic(m->mono_time);
+
+                    if (raw_msg_len <= TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
+                        memcpy(data->msg_data, raw_message, raw_msg_len);
+                    } else {
+                        // HINT: this should never happen
+                        memcpy(data->msg_data, raw_message, TOX_MAX_FILETRANSFER_SIZE_MSGV2);
+                    }
+
+                    uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+                    if (friend_pubkey) {
+                        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+                        if (res == true) {
+                            tox_utils_housekeeping(tox);
+                            tox_utils_list_add(&global_msgv2_outgoing_ft_list, friend_pubkey,
+                                               file_num_new, data);
+                            //Messenger *m = (Messenger *)tox;
+                            //LOGGER_WARNING(m->log,
+                            //               "toxutil:tox_util_friend_send_message_v2:TOX_FILE_KIND_MESSAGEV2_ANSWER:%d:%d",
+                            //               (int)friend_number, (int)file_num_new);
+                        }
+
+                        free(friend_pubkey);
+                        free(raw_message);
+                        return true;
+
+                    } else {
+                        free(data);
+
+                        free(raw_message);
+                        return false;
+                    }
+                }
+
+                free(raw_message);
+                return false;
+            } else {
+                free(raw_message);
+                return false;
+            }
+        } else {
+            return false;
+        }
+    } else {
+        return false;
+    }
+}
+
+bool tox_util_friend_resend_message_v2(Tox *tox, uint32_t friend_number,
+                                       const uint8_t *raw_message, const uint32_t raw_msg_len,
+                                       TOX_ERR_FRIEND_SEND_MESSAGE *error)
+{
+
+    if (error) {
+        // TODO: make this better
+        // use some "random" error value for now
+        *error = TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ;
+    }
+
+    uint8_t *msgid = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+    if (!msgid) {
+        return false;
+    }
+
+    bool res2 = tox_messagev2_get_message_id(raw_message, msgid);
+
+    if (res2 == false) {
+        free(msgid);
+        return false;
+    }
+
+    // now send it
+    const char *filename = "messagev2.txt";
+    TOX_ERR_FILE_SEND error_send;
+    uint32_t file_num_new = tox_file_send(tox, friend_number,
+                                          (uint32_t)TOX_FILE_KIND_MESSAGEV2_SEND,
+                                          (uint64_t)raw_msg_len, (const uint8_t *)msgid,
+                                          (const uint8_t *)filename, (size_t)strlen(filename),
+                                          &error_send);
+
+    if ((file_num_new == UINT32_MAX) || (error_send != TOX_ERR_FILE_SEND_OK)) {
+        free(msgid);
+        return false;
+    }
+
+    global_msgv2_outgoing_ft_entry *data = calloc(1, sizeof(global_msgv2_outgoing_ft_entry));
+
+    if (data) {
+        data->friend_number = friend_number;
+        data->file_number = file_num_new;
+        data->kind = TOX_FILE_KIND_MESSAGEV2_SEND;
+        data->file_size = raw_msg_len;
+        Messenger *m = *(Messenger **)tox;
+        data->timestamp = current_time_monotonic(m->mono_time);
+
+        if (raw_msg_len <= TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
+            memcpy(data->msg_data, raw_message, raw_msg_len);
+        } else {
+            // HINT: this should never happen
+            memcpy(data->msg_data, raw_message, TOX_MAX_FILETRANSFER_SIZE_MSGV2);
+        }
+
+        uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+        if (friend_pubkey) {
+            bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+            if (res == true) {
+                tox_utils_housekeeping(tox);
+                tox_utils_list_add(&global_msgv2_outgoing_ft_list, friend_pubkey,
+                                   file_num_new, data);
+                //Messenger *m = (Messenger *)tox;
+                //LOGGER_WARNING(m->log,
+                //               "toxutil:tox_util_friend_resend_message_v2:TOX_FILE_KIND_MESSAGEV2_SEND:%d:%d",
+                //               (int)friend_number, (int)file_num_new);
+            }
+
+            free(friend_pubkey);
+        } else {
+            free(data);
+        }
+    }
+
+    if (error) {
+        *error = TOX_ERR_FRIEND_SEND_MESSAGE_OK;
+    }
+
+    return true;
+}
+
+bool tox_util_friend_send_sync_message_v2(Tox *tox, uint32_t friend_number,
+        const uint8_t *raw_message, const uint32_t raw_msg_len,
+        TOX_ERR_FRIEND_SEND_MESSAGE *error)
+{
+
+    if (error) {
+        // TODO: make this better
+        // use some "random" error value for now
+        *error = TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ;
+    }
+
+    uint8_t *msgid = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+    if (!msgid) {
+        return false;
+    }
+
+    bool res2 = tox_messagev2_get_message_id(raw_message, msgid);
+
+    if (res2 == false) {
+        free(msgid);
+        return false;
+    }
+
+    // now send it
+    const char *filename = "messagev2.txt"; // TODO: should sync messages have a different filename?
+    TOX_ERR_FILE_SEND error_send;
+    uint32_t file_num_new = tox_file_send(tox, friend_number,
+                                          (uint32_t)TOX_FILE_KIND_MESSAGEV2_SYNC,
+                                          (uint64_t)raw_msg_len, (const uint8_t *)msgid,
+                                          (const uint8_t *)filename, (size_t)strlen(filename),
+                                          &error_send);
+
+    if ((file_num_new == UINT32_MAX) || (error_send != TOX_ERR_FILE_SEND_OK)) {
+        free(msgid);
+        return false;
+    }
+
+    global_msgv2_outgoing_ft_entry *data = calloc(1, sizeof(global_msgv2_outgoing_ft_entry));
+
+    if (data) {
+        data->friend_number = friend_number;
+        data->file_number = file_num_new;
+        data->kind = TOX_FILE_KIND_MESSAGEV2_SYNC;
+        data->file_size = raw_msg_len;
+        Messenger *m = *(Messenger **)tox;
+        data->timestamp = current_time_monotonic(m->mono_time);
+
+        if (raw_msg_len <= TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
+            memcpy(data->msg_data, raw_message, raw_msg_len);
+        } else {
+            // HINT: this should never happen
+            memcpy(data->msg_data, raw_message, TOX_MAX_FILETRANSFER_SIZE_MSGV2);
+        }
+
+        uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+        if (friend_pubkey) {
+            bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+            if (res == true) {
+                tox_utils_housekeeping(tox);
+                tox_utils_list_add(&global_msgv2_outgoing_ft_list, friend_pubkey,
+                                   file_num_new, data);
+                //Messenger *m = (Messenger *)tox;
+                //LOGGER_WARNING(m->log,
+                //               "toxutil:tox_util_friend_resend_message_v2:TOX_FILE_KIND_MESSAGEV2_SEND:%d:%d",
+                //               (int)friend_number, (int)file_num_new);
+            }
+
+            free(friend_pubkey);
+        } else {
+            free(data);
+        }
+    }
+
+    if (error) {
+        *error = TOX_ERR_FRIEND_SEND_MESSAGE_OK;
+    }
+
+    return true;
+}
+
+int64_t tox_util_friend_send_message_v2(Tox *tox, uint32_t friend_number, TOX_MESSAGE_TYPE type,
+                                        uint32_t ts_sec, const uint8_t *message, size_t length,
+                                        uint8_t *raw_message_back, uint32_t *raw_msg_len_back,
+                                        uint8_t *msgid_back,
+                                        TOX_ERR_FRIEND_SEND_MESSAGE *error)
+{
+    if (message) {
+        bool friend_has_msgv2 = tox_utils_get_capabilities(tox, friend_number);
+
+        // DEBUG ==========================
+        // DEBUG ==========================
+        // friend_has_msgv2 = true;
+        // DEBUG ==========================
+        // DEBUG ==========================
+
+        if (friend_has_msgv2 == true) {
+            if (error) {
+                // TODO: make this better
+                // use some "random" error value for now
+                *error = TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ;
+            }
+
+            // indicate messageV2 was used to send
+            if (length > TOX_MESSAGEV2_MAX_TEXT_LENGTH) {
+                return -1;
+            }
+
+            uint32_t raw_msg_len = tox_messagev2_size((uint32_t)length,
+                                   (uint32_t)TOX_FILE_KIND_MESSAGEV2_SEND, 0);
+
+            uint8_t *raw_message = calloc(1, (size_t)raw_msg_len);
+
+            if (!raw_message) {
+                return -1;
+            }
+
+            uint8_t *msgid = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+            if (!msgid) {
+                free(raw_message);
+                return -1;
+            }
+
+            bool result = tox_messagev2_wrap((uint32_t)length,
+                                             (uint32_t)TOX_FILE_KIND_MESSAGEV2_SEND,
+                                             0,
+                                             message, ts_sec,
+                                             global_ts_ms,
+                                             raw_message,
+                                             msgid);
+
+
+// --- DEBUG ---
+#if 0
+            Messenger *m = *(Messenger **)tox;
+            char      data_hex_str[5000];
+            get_hex((raw_message + 32 + 4 + 2), (raw_msg_len - 32 - 4 - 2), data_hex_str, 5000, 16);
+            LOGGER_WARNING(m->log, "%s", data_hex_str);
+
+
+            LOGGER_WARNING(m->log,
+                           "toxutil:tox_util_friend_send_message_v2:0:FT:%d:%d",
+                           (int)raw_msg_len, (int)length);
+            LOGGER_WARNING(m->log,
+                           "toxutil:tox_util_friend_send_message_v2:A:FT:%s",
+                           message);
+            LOGGER_WARNING(m->log,
+                           "toxutil:tox_util_friend_send_message_v2:B:FT:%s",
+                           (char *)(raw_message + 32 + 4 + 2));
+#endif
+// --- DEBUG ---
+
+
+            // every message should have an increasing "dummy" ms-timestamp part
+            global_ts_ms++;
+
+            if (result == true) {
+                // ok we have our raw message in "raw_message" and the length in "raw_msg_len"
+
+                // give raw message and the length back to caller
+                if (raw_message_back) {
+                    memcpy(raw_message_back, raw_message, raw_msg_len);
+
+                    if (raw_msg_len_back) {
+                        *raw_msg_len_back = raw_msg_len;
+                    }
+                }
+
+                // give message id (= message hash) back to caller
+                if (msgid_back) {
+                    memcpy(msgid_back, msgid, TOX_PUBLIC_KEY_SIZE);
+                }
+
+                // now send it
+                const char *filename = "messagev2.txt";
+                TOX_ERR_FILE_SEND error_send;
+                uint32_t file_num_new = tox_file_send(tox, friend_number,
+                                                      (uint32_t)TOX_FILE_KIND_MESSAGEV2_SEND,
+                                                      (uint64_t)raw_msg_len, (const uint8_t *)msgid,
+                                                      (const uint8_t *)filename, (size_t)strlen(filename),
+                                                      &error_send);
+
+                if ((file_num_new == UINT32_MAX) || (error_send != TOX_ERR_FILE_SEND_OK)) {
+                    free(raw_message);
+                    free(msgid);
+
+                    return -1;
+                }
+
+                global_msgv2_outgoing_ft_entry *data = calloc(1, sizeof(global_msgv2_outgoing_ft_entry));
+
+                if (data) {
+                    data->friend_number = friend_number;
+                    data->file_number = file_num_new;
+                    data->kind = TOX_FILE_KIND_MESSAGEV2_SEND;
+                    data->file_size = raw_msg_len;
+                    Messenger *m = *(Messenger **)tox;
+                    data->timestamp = current_time_monotonic(m->mono_time);
+
+                    if (raw_msg_len <= TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
+                        memcpy(data->msg_data, raw_message, raw_msg_len);
+                    } else {
+                        // HINT: this should never happen
+                        memcpy(data->msg_data, raw_message, TOX_MAX_FILETRANSFER_SIZE_MSGV2);
+                    }
+
+                    uint8_t *friend_pubkey = calloc(1, TOX_PUBLIC_KEY_SIZE);
+
+                    if (friend_pubkey) {
+                        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);
+
+                        if (res == true) {
+                            tox_utils_housekeeping(tox);
+                            tox_utils_list_add(&global_msgv2_outgoing_ft_list, friend_pubkey,
+                                               file_num_new, data);
+                            //Messenger *m = (Messenger *)tox;
+                            //LOGGER_WARNING(m->log,
+                            //               "toxutil:tox_util_friend_send_message_v2:TOX_FILE_KIND_MESSAGEV2_SEND:%d:%d",
+                            //               (int)friend_number, (int)file_num_new);
+                        }
+
+                        free(friend_pubkey);
+                    } else {
+                        free(data);
+                    }
+                }
+
+                free(raw_message);
+                free(msgid);
+
+                if (error) {
+                    *error = TOX_ERR_FRIEND_SEND_MESSAGE_OK;
+                }
+            }
+
+            return -1;
+        } else {
+            // wrap old message send function
+
+            //Messenger *m = (Messenger *)tox;
+            //LOGGER_WARNING(m->log,
+            //               "toxutil:tox_util_friend_send_message_v2:WRAP-OLD:%d",
+            //               (int)friend_number);
+
+            return tox_friend_send_message(tox, friend_number, type, message,
+                                           length, error);
+        }
+    } else {
+        return -1;
+    }
+}
+
+#pragma GCC diagnostic pop
+
+//!TOKSTYLE+
diff --git a/toxutil/toxutil.h b/toxutil/toxutil.h
new file mode 100644
index 000000000..a9f6138d0
--- /dev/null
+++ b/toxutil/toxutil.h
@@ -0,0 +1,163 @@
+/*
+ * Copyright © 2018 Zoff
+ *
+ * This file is part of Tox, the free peer to peer instant messenger.
+ *
+ * Tox is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Tox is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TOXUTIL_H
+#define TOXUTIL_H
+
+//!TOKSTYLE-
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define TOX_CAPABILITY_BASIC 0
+#define TOX_CAPABILITY_CAPABILITIES ((uint64_t)1) << 0
+#define TOX_CAPABILITY_MSGV2 ((uint64_t)1) << 1
+#define TOX_CAPABILITY_TOXAV_H264 ((uint64_t)1) << 2
+
+void tox_utils_callback_self_connection_status(Tox *tox, tox_self_connection_status_cb *callback);
+void tox_utils_self_connection_status_cb(Tox *tox,
+        TOX_CONNECTION connection_status, void *user_data);
+
+void tox_utils_callback_friend_connection_status(Tox *tox,
+        tox_friend_connection_status_cb *callback);
+void tox_utils_friend_connection_status_cb(Tox *tox, uint32_t friendnumber,
+        TOX_CONNECTION connection_status, void *user_data);
+
+void tox_utils_callback_friend_lossless_packet(Tox *tox,
+        tox_friend_lossless_packet_cb *callback);
+void tox_utils_friend_lossless_packet_cb(Tox *tox, uint32_t friend_number,
+        const uint8_t *data, size_t length, void *user_data);
+
+void tox_utils_callback_file_recv_control(Tox *tox, tox_file_recv_control_cb *callback);
+void tox_utils_file_recv_control_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
+                                    TOX_FILE_CONTROL control, void *user_data);
+
+void tox_utils_callback_file_chunk_request(Tox *tox, tox_file_chunk_request_cb *callback);
+void tox_utils_file_chunk_request_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
+                                     uint64_t position, size_t length, void *user_data);
+
+void tox_utils_callback_file_recv(Tox *tox, tox_file_recv_cb *callback);
+void tox_utils_file_recv_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
+                            uint32_t kind, uint64_t file_size,
+                            const uint8_t *filename, size_t filename_length, void *user_data);
+
+void tox_utils_callback_file_recv_chunk(Tox *tox, tox_file_recv_chunk_cb *callback);
+void tox_utils_file_recv_chunk_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
+                                  uint64_t position, const uint8_t *data, size_t length,
+                                  void *user_data);
+
+
+// ---- Msg V2 API ----
+
+// HINT: receive a message in new messageV2 format
+//       (you still need to register the "old" callback "tox_friend_message_cb"
+//       to receive old format messages)
+// params: message       raw messageV2 data incl. header
+//         length        length of raw messageV2 data incl. header
+typedef void tox_util_friend_message_v2_cb(Tox *tox, uint32_t friend_number,
+        const uint8_t *message, size_t length);
+
+void tox_utils_callback_friend_message_v2(Tox *tox, tox_util_friend_message_v2_cb *callback);
+
+
+// HINT: receive a sync message in new messageV2 format
+// params: message       raw messageV2 data incl. header
+//         length        length of raw messageV2 data incl. header
+typedef void tox_util_friend_sync_message_v2_cb(Tox *tox, uint32_t friend_number,
+        const uint8_t *message, size_t length);
+
+void tox_utils_callback_friend_sync_message_v2(Tox *tox, tox_util_friend_sync_message_v2_cb *callback);
+
+
+// HINT: receive message receipt (ACK)
+// params: friend_number friend
+//         ts_sec        unixtimestamp when message was received by the friend (in seconds since epoch)
+//         msgid         buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
+typedef void tox_utils_friend_read_receipt_message_v2_cb(Tox *tox, uint32_t friend_number,
+        uint32_t ts_sec, const uint8_t *msgid);
+
+void tox_utils_callback_friend_read_receipt_message_v2(Tox *tox,
+        tox_utils_friend_read_receipt_message_v2_cb *callback);
+
+
+// HINT: use only this API function to send messages (it will automatically send old format if needed)
+// params: friend_number friend to send message to
+//         type          type of message (only used for old style messages)
+//         ts_sec        unixtimestamp when message was sent (in seconds since epoch)
+//         message       buffer with message text
+//         length        bytes in buffer of message text
+//         raw_message_back buffer of TOX_MAX_FILETRANSFER_SIZE_MSGV2 size
+//                       the raw message (incl. header) will be put there
+//         raw_msg_len_back number of bytes the raw message actually uses in the buffer
+//         msgid_back    buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
+//         error         error code used for both old and new style messages
+// return: int64_t       always -1 for new style messages (to indicate new style was used)
+//         int64_t       return value of tox_friend_send_message() for old style messages
+//                       (can't be negative)
+int64_t tox_util_friend_send_message_v2(Tox *tox, uint32_t friend_number, TOX_MESSAGE_TYPE type,
+                                        uint32_t ts_sec, const uint8_t *message, size_t length,
+                                        uint8_t *raw_message_back, uint32_t *raw_msg_len_back,
+                                        uint8_t *msgid_back,
+                                        TOX_ERR_FRIEND_SEND_MESSAGE *error);
+
+// resend a message
+// params: friend_number friend to send message to
+//         raw_message   buffer of the raw message (incl. header)
+//         raw_msg_len   number of bytes length of raw message
+// return: bool          true -> if message was sent OK
+bool tox_util_friend_resend_message_v2(Tox *tox, uint32_t friend_number,
+                                       const uint8_t *raw_message,
+                                       const uint32_t raw_msg_len,
+                                       TOX_ERR_FRIEND_SEND_MESSAGE *error);
+
+// send a sync message
+// params: friend_number friend to send message to
+//         raw_message   buffer of the raw message (incl. header)
+//         raw_msg_len   number of bytes length of raw message
+// return: bool          true -> if message was sent OK
+bool tox_util_friend_send_sync_message_v2(Tox *tox, uint32_t friend_number,
+        const uint8_t *raw_message, const uint32_t raw_msg_len,
+        TOX_ERR_FRIEND_SEND_MESSAGE *error);
+// send message receipt
+// params: friend_number friend to send message to
+//         msgid         buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
+//         ts_sec        unixtimestamp when message was received (in seconds since epoch)
+bool tox_util_friend_send_msg_receipt_v2(Tox *tox, uint32_t friend_number, uint8_t *msgid, uint32_t ts_sec);
+
+
+// ---- Msg V2 API ----
+
+
+Tox *tox_utils_new(const struct Tox_Options *options, TOX_ERR_NEW *error);
+void tox_utils_kill(Tox *tox);
+bool tox_utils_friend_delete(Tox *tox, uint32_t friend_number, TOX_ERR_FRIEND_DELETE *error);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+//!TOKSTYLE+
+
+#endif
